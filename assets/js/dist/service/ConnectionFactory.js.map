{"version":3,"sources":["../../src/service/ConnectionFactory.js"],"names":["dbName","version","stores","connection","close","ConnectionFactory","Error","Promise","resolve","reject","openRequest","window","indexedDB","open","onsuccess","e","target","result","bind","onerror","error","name","onupgradeneeded","_createStores","forEach","objectStoreNames","contains","store","deleteObjectStore","createObjectStore","autoIncrement"],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAMA,kB,GAAS,W;AACTC,mB,GAAU,C;AACVC,kB,GAAS,CAAC,QAAD,C;AAEXC,sB,GAAa,I;AACbC,iB,GAAQ,I;;yCAECC,iB;AAET,6CAAc;AAAA;;AAEV,0BAAM,IAAIC,KAAJ,CAAU,oCAAV,CAAN;AACH;;;;oDAEsB;;AAEnB,+BAAO,IAAIC,OAAJ,CAAY,UAACC,OAAD,EAAUC,MAAV,EAAqB;;AAEpC,gCAAIC,cAAcC,OAAOC,SAAP,CAAiBC,IAAjB,CAAsBb,MAAtB,EAA8BC,OAA9B,CAAlB;;AAEAS,wCAAYI,SAAZ,GAAwB,aAAK;;AAEzB,oCAAK,CAACX,UAAN,EAAmB;AACfA,iDAAaY,EAAEC,MAAF,CAASC,MAAtB;AACAb,4CAAQD,WAAWC,KAAX,CAAiBc,IAAjB,CAAsBf,UAAtB,CAAR;AACAA,+CAAWC,KAAX,GAAmB,YAAW;AAC1B,8CAAM,IAAIE,KAAJ,CAAU,gDAAV,CAAN;AACH,qCAFD;AAGH;;AAEDE,wCAAQL,UAAR;AACH,6BAXD;;AAaAO,wCAAYS,OAAZ,GAAsB;AAAA,uCAClBV,OAAOM,EAAEC,MAAF,CAASI,KAAT,CAAeC,IAAtB,CADkB;AAAA,6BAAtB;;AAGAX,wCAAYY,eAAZ,GAA8B;AAAA,uCAC1BjB,kBAAkBkB,aAAlB,CAAgCR,EAAEC,MAAF,CAASC,MAAzC,CAD0B;AAAA,6BAA9B;AAGH,yBAvBM,CAAP;AAwBH;;;sDAEwB;;AAErB,4BAAKd,UAAL,EAAkB;AACdC;AACAD,yCAAa,IAAb;AACH;AACJ;;;kDAEoBA,U,EAAY;;AAE7BD,+BAAOsB,OAAP,CAAe,iBAAS;;AAEpB,gCAAKrB,WAAWsB,gBAAX,CAA4BC,QAA5B,CAAqCC,KAArC,CAAL,EACIxB,WAAWyB,iBAAX,CAA6BD,KAA7B;;AAEJxB,uCAAW0B,iBAAX,CAA6BF,KAA7B,EAAoC,EAAEG,eAAe,IAAjB,EAApC;AACH,yBAND;AAOH","file":"ConnectionFactory.js","sourcesContent":["const dbName = 'orderbook';\nconst version = 2;\nconst stores = ['orders'];\n\nlet connection = null;\nlet close = null;\n\nexport class ConnectionFactory {\n\n    constructor() {\n\n        throw new Error('This class cannot be instantiated.');\n    }\n\n    static getConnection() {\n\n        return new Promise((resolve, reject) => {\n\n            let openRequest = window.indexedDB.open(dbName, version);\n\n            openRequest.onsuccess = e => {\n\n                if ( !connection ) {\n                    connection = e.target.result;\n                    close = connection.close.bind(connection);\n                    connection.close = function() {\n                        throw new Error('Just ConnectionFactory can close a connection.');\n                    }\n                }\n\n                resolve(connection);\n            }\n\n            openRequest.onerror = e =>\n                reject(e.target.error.name);\n\n            openRequest.onupgradeneeded = e =>\n                ConnectionFactory._createStores(e.target.result);\n\n        })\n    }\n    \n    static closeConnection() {\n\n        if ( connection ) {\n            close();\n            connection = null;\n        }\n    }\n\n    static _createStores(connection) {\n\n        stores.forEach(store => {\n\n            if ( connection.objectStoreNames.contains(store) )\n                connection.deleteObjectStore(store);\n            \n            connection.createObjectStore(store, { autoIncrement: true });\n        });\n    }\n}"]}